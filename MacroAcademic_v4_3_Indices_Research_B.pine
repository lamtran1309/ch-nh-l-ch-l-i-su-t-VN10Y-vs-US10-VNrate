//@version=5
indicator("Macro → VN Indices Research (Script B)",
     shorttitle="MacroIndices Map v1.0",
     overlay=false,
     max_labels_count=500,
     max_lines_count=500,
     max_bars_back=5000)

// =====================
// 0) ADVANCED HELPER FUNCTIONS (SHARED WITH SCRIPT A)
// =====================

// Robust z-score with winsorization (clip outliers)
f_robust_zscore(src, length, clip_multiplier) =>
    _mean = ta.sma(src, length)
    _std  = ta.stdev(src, length)

    upper_bound = _mean + clip_multiplier * _std
    lower_bound = _mean - clip_multiplier * _std
    clipped_src = math.max(lower_bound, math.min(upper_bound, src))

    clipped_mean = ta.sma(clipped_src, length)
    clipped_std  = ta.stdev(clipped_src, length)

    clipped_std > 0 ? (src - clipped_mean) / clipped_std : 0.0

// Percentile threshold
f_percentile_threshold(src, length, percentile_val) =>
    ta.percentile_linear_interpolation(src, length, percentile_val)

// Percentile warning check
f_check_percentile_warning(src, length, percentile_val, is_low_bad) =>
    threshold_val = f_percentile_threshold(src, length, percentile_val)
    is_low_bad ? src <= threshold_val : src >= threshold_val

// Bucket mapping from risk_pct (0–100) to 5 regimes
f_bucket_from_risk(risk) =>
    int b = na
    if not na(risk)
        b := risk < 20 ? 0 :
             risk < 40 ? 1 :
             risk < 60 ? 2 :
             risk < 80 ? 3 : 4
    b

f_bucket_label(b) =>
    b == 0 ? "B0 (0–20)" :
     b == 1 ? "B1 (20–40)" :
     b == 2 ? "B2 (40–60)" :
     b == 3 ? "B3 (60–80)" :
     b == 4 ? "B4 (80–100)" : "NA"

// Simple helpers for stats
f_avg(sum, cnt) =>
    cnt > 0 ? sum / cnt : na

f_winrate(win, cnt) =>
    cnt > 0 ? win / cnt * 100.0 : na

// Academic return handling: optional log return + clipping
group_acad = "Academic options"

use_log_return = input.bool(false, "Use log returns (hoc thuat hon)", group=group_acad)
ret_clip_up    = input.float(2.0,  "Clip upper return (R max)",  minval=0.1,  maxval=10.0,  step=0.1,  group=group_acad)
ret_clip_down  = input.float(-0.8, "Clip lower return (R min)",  minval=-0.99, maxval=0.0, step=0.05, group=group_acad)

f_clip_ret(r) =>
    na(r) ? na : math.max(ret_clip_down, math.min(ret_clip_up, r))

f_compute_return(c, c_L) =>
    not na(c) and not na(c_L) ?
     (use_log_return ? math.log(c / c_L) : c / c_L - 1.0) :
     na

f_update_return_stats(float[] sumArr, float[] cntArr, float[] winArr, int idx, float ret_raw) =>
    float ret = f_clip_ret(ret_raw)
    if not na(ret)
        float prevSum = array.get(sumArr, idx)
        float prevCnt = array.get(cntArr, idx)
        float prevWin = array.get(winArr, idx)
        float newCnt  = prevCnt + 1.0
        array.set(sumArr, idx, prevSum + ret)
        array.set(cntArr, idx, newCnt)
        if ret > 0
            array.set(winArr, idx, prevWin + 1.0)

f_update_dd_stats(float[] sumArr, float[] cntArr, int idx, float dd) =>
    if not na(dd)
        float prevSum = array.get(sumArr, idx)
        float prevCnt = array.get(cntArr, idx)
        float newCnt  = prevCnt + 1.0
        array.set(sumArr, idx, prevSum + dd)
        array.set(cntArr, idx, newCnt)

// =====================
// 1) MACRO ENGINE (REPLICATED FROM SCRIPT A → risk_pct)
// =====================

group_macro = "Macro inputs"

tf_macro = input.timeframe("D", "Macro timeframe (khuyen nghi: D)", group=group_macro)

policy_rate     = request.security("VNINTR", tf_macro, close, barmerge.gaps_off, barmerge.lookahead_off)
bond_2y         = request.security("VN02Y",  tf_macro, close, barmerge.gaps_off, barmerge.lookahead_off)
bond_10y        = request.security("VN10Y",  tf_macro, close, barmerge.gaps_off, barmerge.lookahead_off)
us_10y          = request.security("US10Y",  tf_macro, close, barmerge.gaps_off, barmerge.lookahead_off)
interbank_rate  = request.security("VNINBR", tf_macro, close, barmerge.gaps_off, barmerge.lookahead_off)

// Spreads (same sign convention as Script A)
liquidity_stress     = interbank_rate - policy_rate    // HIGH = BAD
yield_curve_standard = bond_10y      - bond_2y         // LOW  = BAD
intl_yield_diff      = bond_10y      - us_10y          // LOW  = BAD
long_short_spread    = bond_10y      - policy_rate     // LOW  = BAD

// Threshold modes (identical to Script A)
threshold_mode = input.string("Percentile-based", "Che do nguong", options = ["Static", "Dynamic (z-score)", "Percentile-based"], group=group_macro)

percentile_lookback = input.int(504, "Chu ky phan phoi (bars)", minval=100, maxval=2000, group=group_macro)

// Percentile thresholds
stress_percentile  = input.int(85, "Stress % (cao = xau)",     minval=50, maxval=99, group=group_macro)
curve_percentile   = input.int(15, "Curve % (thap = xau)",     minval=1,  maxval=50, group=group_macro)
intl_percentile    = input.int(15, "Intl diff % (thap = xau)", minval=1,  maxval=50, group=group_macro)
spread_percentile  = input.int(15, "Spread % (thap = xau)",    minval=1,  maxval=50, group=group_macro)

// Robust z-score parameters
len_stats       = input.int(252,  "Chu ky thong ke (z-score)", minval=60, group=group_macro)
clip_multiplier = input.float(2.5, "Clip outliers (std)", minval=1.5, maxval=4.0, step=0.1, group=group_macro)

// Z-score thresholds
z_stress_threshold = input.float(1.0,  "[Z-score] Stress threshold (Z >)", step=0.1, group=group_macro)
z_curve_threshold  = input.float(-1.0, "[Z-score] Curve threshold  (Z <)", step=0.1, group=group_macro)
z_intl_threshold   = input.float(-1.0, "[Z-score] Intl threshold   (Z <)", step=0.1, group=group_macro)
z_spread_threshold = input.float(-1.0, "[Z-score] Spread threshold (Z <)", step=0.1, group=group_macro)

// Static thresholds
stress_threshold = input.float(1.5, "[Static] Cang thanh khoan",      step=0.1, group=group_macro)
curve_threshold  = input.float(0.0, "[Static] Dao nguoc (10Y-2Y)",    step=0.1, group=group_macro)
intl_threshold   = input.float(2.0, "[Static] Chenh lech QT",         step=0.1, group=group_macro)
spread_threshold = input.float(3.0, "[Static] Spread ngan-dai",       step=0.1, group=group_macro)

// Percentile thresholds (series)
stress_percentile_val = f_percentile_threshold(liquidity_stress,     percentile_lookback, stress_percentile)
curve_percentile_val  = f_percentile_threshold(yield_curve_standard, percentile_lookback, curve_percentile)
intl_percentile_val   = f_percentile_threshold(intl_yield_diff,      percentile_lookback, intl_percentile)
spread_percentile_val = f_percentile_threshold(long_short_spread,    percentile_lookback, spread_percentile)

// Robust z-scores
stress_z_robust = f_robust_zscore(liquidity_stress,     len_stats, clip_multiplier)
curve_z_robust  = f_robust_zscore(yield_curve_standard, len_stats, clip_multiplier)
intl_z_robust   = f_robust_zscore(intl_yield_diff,      len_stats, clip_multiplier)
spread_z_robust = f_robust_zscore(long_short_spread,    len_stats, clip_multiplier)

use_percentile = threshold_mode == "Percentile-based"
use_dynamic    = threshold_mode == "Dynamic (z-score)"
use_static     = threshold_mode == "Static"

// 4-pillar signals (same logic as Script A)
bool stress_high     = false
bool curve_inversion = false
bool intl_warning    = false
bool spread_warning  = false

if use_percentile
    stress_high     := f_check_percentile_warning(liquidity_stress,     percentile_lookback, stress_percentile, false) // high bad
    curve_inversion := f_check_percentile_warning(yield_curve_standard, percentile_lookback, curve_percentile,  true)  // low bad
    intl_warning    := f_check_percentile_warning(intl_yield_diff,      percentile_lookback, intl_percentile,   true)  // low bad
    spread_warning  := f_check_percentile_warning(long_short_spread,    percentile_lookback, spread_percentile, true)  // low bad
else if use_dynamic
    stress_high     := stress_z_robust  > z_stress_threshold
    curve_inversion := curve_z_robust   < z_curve_threshold
    intl_warning    := intl_z_robust    < z_intl_threshold
    spread_warning  := spread_z_robust  < z_spread_threshold
else
    stress_high     := liquidity_stress     > stress_threshold
    curve_inversion := yield_curve_standard < curve_threshold
    intl_warning    := intl_yield_diff      < intl_threshold
    spread_warning  := long_short_spread    < spread_threshold

// Composite risk score (must match Script A)
w_stress = input.int(2, "Trong so Cang thanh khoan", group=group_macro)
w_curve  = input.int(2, "Trong so Yield curve (10Y-2Y)", group=group_macro)
w_intl   = input.int(1, "Trong so Chenh lech QT", group=group_macro)
w_spread = input.int(1, "Trong so Spread ngan-dai", group=group_macro)

int risk_score = 0
risk_score += stress_high     ? w_stress : 0
risk_score += curve_inversion ? w_curve  : 0
risk_score += intl_warning    ? w_intl   : 0
risk_score += spread_warning  ? w_spread : 0

max_score  = w_stress + w_curve + w_intl + w_spread
risk_ratio = max_score > 0 ? risk_score / max_score : 0.0
risk_pct   = risk_ratio * 100.0

// Simple plot of macro risk to check sync vs Script A
plot(risk_pct, title="Macro Risk % (0–100)", color=color.new(color.orange, 0), linewidth=2)
plot(20, title="Risk bucket 20", color=color.new(color.gray, 80), linewidth=1, style=plot.style_line)
plot(40, title="Risk bucket 40", color=color.new(color.gray, 80), linewidth=1, style=plot.style_line)
plot(60, title="Risk bucket 60", color=color.new(color.gray, 80), linewidth=1, style=plot.style_line)
plot(80, title="Risk bucket 80", color=color.new(color.gray, 80), linewidth=1, style=plot.style_line)

// =====================
// Label risk hien tai tren duong cam
// =====================
var label risk_label = na

if barstate.islast
    if not na(risk_label)
        label.delete(risk_label)

    int b_now = f_bucket_from_risk(risk_pct)
    if na(b_now)
        b_now := 2

    string risk_txt = "Risk " + str.tostring(risk_pct, "#.#") + "%  |  " + f_bucket_label(b_now)
    risk_label := label.new(
         bar_index, risk_pct,
         risk_txt,
         style     = label.style_label_left,
         textcolor = color.white,
         color     = color.new(color.blue, 70),
         size      = size.small)

// =====================
// 2) EQUITY CONFIG (HOSE INDICES + FEATURES)
// =====================

group_equity = "Equity mapping & features"

tf_equity   = input.timeframe("D", "Equity timeframe (khuyen nghi: D)", group=group_equity)

// Feature toggles – kiểm soát tải nhưng không cắt danh sách symbol
calc_R5   = input.bool(false, "Tinh R5 (5-bar return)", group=group_equity)
calc_R20  = input.bool(true,  "Tinh R20 (20-bar return)", group=group_equity)
calc_R60  = input.bool(false, "Tinh R60 (60-bar return)", group=group_equity)
calc_DD20 = input.bool(false, "Tinh Drawdown 20", group=group_equity)
calc_DD60 = input.bool(false, "Tinh Drawdown 60", group=group_equity)

// View options
group_view = "View / Bucket"

bucket_view = input.string("Auto (current)", "Bucket view",
     options = ["Auto (current)", "B0 (0–20)", "B1 (20–40)", "B2 (40–60)", "B3 (60–80)", "B4 (80–100)"],
     group   = group_view)
show_bucket_guide = input.bool(true, "Panel 1: Hien thi Bucket Guide", group=group_view)

show_R60_cols = input.bool(true,  "Bang A: Hien thi AvgR60", group=group_view)
show_DD_cols  = input.bool(true,  "Bang A: Hien thi AvgDD20", group=group_view)
min_N_market  = input.int(30, "Min N20 de hien thi (Table A)", minval=1, group=group_view)
min_N_sector  = input.int(30, "Min N (RR20) de ranking (Table B)", minval=1, group=group_view)

// =====================
// UI – PANEL VIEW
// =====================
group_ui = "UI / Panel view"

panel_view = input.string(
     "Panel 1 – Macro Weather",
     "Chon panel hien thi",
     options = [
         "Panel 1 – Macro Weather",
         "Panel 2 – Market Regime Map",
         "Panel 3 – Sector Rotation Map",
         "Panel 4 – Transition Summary"
     ],
     group = group_ui)

bool show_panel1 = panel_view == "Panel 1 – Macro Weather"
bool show_panel2 = panel_view == "Panel 2 – Market Regime Map"
bool show_panel3 = panel_view == "Panel 3 – Sector Rotation Map"
bool show_panel4 = panel_view == "Panel 4 – Transition Summary"

// =====================
// 9) TRANSITION MATRIX (TABLE C)
// =====================
group_trans = "Table C – Transition (Macro buckets)"

show_trans_table  = input.bool(true,  "Hien thi Table C (Transition matrix)", group=group_trans)
trans_L           = input.int(20,     "Transition horizon L (bars)", minval=5, maxval=252, group=group_trans)
trans_show_avgRet = input.bool(true,  "Hien thi Avg benchmark return", group=group_trans)
trans_show_prob   = input.bool(true,  "Hien thi Row probability %", group=group_trans)
min_N_trans       = input.int(30,     "Min N cho o Transition", minval=1, group=group_trans)

// =====================
// Academic / sample controls
// =====================
group_sample = "Sample window (Academic)"
group_debug  = "Academic / Debug"

use_start_year = input.bool(false, "Chi thong ke tu nam ...", group=group_sample)
start_year     = input.int(2015, "Nam bat dau thong ke", minval=2000, maxval=2100, group=group_sample)

use_non_overlap = input.bool(false, "Use NON-overlapping samples (hoc thuat hon)", group=group_acad)

reset_stats = input.bool(false, "Reset statistics (toggle = reset)", group=group_debug)

// 5x5 = 25 cells: fromBucket * 5 + toBucket
var float[] transCnt    = array.new_float(25, 0.0)
var float[] transSumRet = array.new_float(25, 0.0)
var float[] transWin    = array.new_float(25, 0.0)

// =====================
// 3) EQUITY DATA – 17 HOSE INDICES + BENCHMARK
// =====================

// Market / size / breadth indices (6)
mkt_vnindex   = request.security("HOSE:VNINDEX",     tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vn30      = request.security("HOSE:VN30",        tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vn100     = request.security("HOSE:VN100",       tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vnall     = request.security("HOSE:VNALLSHARE",  tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vnmid     = request.security("HOSE:VNMIDCAP",    tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vnsmall   = request.security("HOSE:VNSMALLCAP",  tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)

mkt_vnindex_low = request.security("HOSE:VNINDEX",    tf_equity, low, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vn30_low    = request.security("HOSE:VN30",       tf_equity, low, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vn100_low   = request.security("HOSE:VN100",      tf_equity, low, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vnall_low   = request.security("HOSE:VNALLSHARE", tf_equity, low, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vnmid_low   = request.security("HOSE:VNMIDCAP",   tf_equity, low, barmerge.gaps_off, barmerge.lookahead_off)
mkt_vnsmall_low = request.security("HOSE:VNSMALLCAP", tf_equity, low, barmerge.gaps_off, barmerge.lookahead_off)

// Sector indices (11)
sec_vnfin      = request.security("HOSE:VNFIN",      tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnfin_sel  = request.security("HOSE:VNFINSELECT", tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnind      = request.security("HOSE:VNIND",      tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnit       = request.security("HOSE:VNIT",       tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnreal     = request.security("HOSE:VNREAL",     tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vncons     = request.security("HOSE:VNCONS",     tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vncond     = request.security("HOSE:VNCOND",     tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnene      = request.security("HOSE:VNENE",      tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnmat      = request.security("HOSE:VNMAT",      tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnheal     = request.security("HOSE:VNHEAL",     tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)
sec_vnuti      = request.security("HOSE:VNUTI",      tf_equity, close, barmerge.gaps_off, barmerge.lookahead_off)

// Benchmark dùng cho RR ngành – cố định HOSE:VNINDEX, tái sử dụng series đã fetch
benchmark_close = mkt_vnindex

// Arrays để xử lý tên theo index (series dữ liệu sẽ lấy bằng hàm getter)
var string[] market_name = array.new_string()

var string[] sector_name = array.new_string()

if barstate.isfirst
    // Market names
    array.push(market_name, "VNINDEX")
    array.push(market_name, "VN30")
    array.push(market_name, "VN100")
    array.push(market_name, "VNALLSHARE")
    array.push(market_name, "VNMIDCAP")
    array.push(market_name, "VNSMALLCAP")

    // Sector names
    array.push(sector_name, "VNFIN")
    array.push(sector_name, "VNFINSELECT")
    array.push(sector_name, "VNIND")
    array.push(sector_name, "VNIT")
    array.push(sector_name, "VNREAL")
    array.push(sector_name, "VNCONS")
    array.push(sector_name, "VNCOND")
    array.push(sector_name, "VNENE")
    array.push(sector_name, "VNMAT")
    array.push(sector_name, "VNHEAL")
    array.push(sector_name, "VNUTI")

// Getter helpers: trả về series theo index (đúng cú pháp Pine, không dùng arr[m])
f_market_close(int m) =>
    m == 0 ? mkt_vnindex :
     m == 1 ? mkt_vn30 :
     m == 2 ? mkt_vn100 :
     m == 3 ? mkt_vnall :
     m == 4 ? mkt_vnmid :
     m == 5 ? mkt_vnsmall : na

f_market_low(int m) =>
    m == 0 ? mkt_vnindex_low :
     m == 1 ? mkt_vn30_low :
     m == 2 ? mkt_vn100_low :
     m == 3 ? mkt_vnall_low :
     m == 4 ? mkt_vnmid_low :
     m == 5 ? mkt_vnsmall_low : na

f_sector_close(int s) =>
    s == 0  ? sec_vnfin :
     s == 1 ? sec_vnfin_sel :
     s == 2 ? sec_vnind :
     s == 3 ? sec_vnit :
     s == 4 ? sec_vnreal :
     s == 5 ? sec_vncons :
     s == 6 ? sec_vncond :
     s == 7 ? sec_vnene :
     s == 8 ? sec_vnmat :
     s == 9 ? sec_vnheal :
     s == 10 ? sec_vnuti : na

// =====================
// 4) DATA MODEL – ARRAYS FOR BUCKETED STATS
// =====================

// 6 market indices * 5 buckets = 30
var float[] sumR5_market   = array.new_float(30, 0.0)
var float[] cntR5_market   = array.new_float(30, 0.0)
var float[] winR5_market   = array.new_float(30, 0.0)

var float[] sumR20_market  = array.new_float(30, 0.0)
var float[] cntR20_market  = array.new_float(30, 0.0)
var float[] winR20_market  = array.new_float(30, 0.0)

var float[] sumR60_market  = array.new_float(30, 0.0)
var float[] cntR60_market  = array.new_float(30, 0.0)
var float[] winR60_market  = array.new_float(30, 0.0)

// Drawdown (market only)
var float[] sumDD20_market = array.new_float(30, 0.0)
var float[] cntDD20_market = array.new_float(30, 0.0)

var float[] sumDD60_market = array.new_float(30, 0.0)
var float[] cntDD60_market = array.new_float(30, 0.0)

// 11 sectors * 5 buckets = 55 (Relative Return vs benchmark)
var float[] sumRR5_sector  = array.new_float(55, 0.0)
var float[] cntRR5_sector  = array.new_float(55, 0.0)
var float[] winRR5_sector  = array.new_float(55, 0.0)

var float[] sumRR20_sector = array.new_float(55, 0.0)
var float[] cntRR20_sector = array.new_float(55, 0.0)
var float[] winRR20_sector = array.new_float(55, 0.0)

var float[] sumRR60_sector = array.new_float(55, 0.0)
var float[] cntRR60_sector = array.new_float(55, 0.0)
var float[] winRR60_sector = array.new_float(55, 0.0)

// =====================
// Academic reset helpers for reproducibility
// =====================

f_reset_float_array(float[] arr) =>
    for i = 0 to array.size(arr) - 1
        array.set(arr, i, 0.0)

f_reset_all_stats() =>
    // Market returns
    f_reset_float_array(sumR5_market)
    f_reset_float_array(cntR5_market)
    f_reset_float_array(winR5_market)

    f_reset_float_array(sumR20_market)
    f_reset_float_array(cntR20_market)
    f_reset_float_array(winR20_market)

    f_reset_float_array(sumR60_market)
    f_reset_float_array(cntR60_market)
    f_reset_float_array(winR60_market)

    // Drawdowns
    f_reset_float_array(sumDD20_market)
    f_reset_float_array(cntDD20_market)
    f_reset_float_array(sumDD60_market)
    f_reset_float_array(cntDD60_market)

    // Sector relative returns
    f_reset_float_array(sumRR5_sector)
    f_reset_float_array(cntRR5_sector)
    f_reset_float_array(winRR5_sector)

    f_reset_float_array(sumRR20_sector)
    f_reset_float_array(cntRR20_sector)
    f_reset_float_array(winRR20_sector)

    f_reset_float_array(sumRR60_sector)
    f_reset_float_array(cntRR60_sector)
    f_reset_float_array(winRR60_sector)

    // Transition matrix
    f_reset_float_array(transCnt)
    f_reset_float_array(transSumRet)
    f_reset_float_array(transWin)

// Thực hiện reset tại bar đầu tiên, hoặc khi người dùng bật reset_stats
bool do_reset = barstate.isfirst or (reset_stats and not reset_stats[1])
if do_reset
    f_reset_all_stats()

// =====================
// 5) UPDATE RULE – LEAD-LAG MAPPING (NO LOOKAHEAD)
// =====================

// Helper: update market stats for horizon L
f_update_market_for_L(int L, float[] sumR, float[] cntR, float[] winR,
                      bool doDD, float[] sumDD, float[] cntDD) =>
    // Macro bucket at t-L (regime state)
    float risk_L = risk_pct[L]
    int bucket   = f_bucket_from_risk(risk_L)
    if not na(bucket)
        // 6 market indices
        for m = 0 to 5
            float c   = f_market_close(m)
            float c_L = c[L]
            float ret = f_compute_return(c, c_L)
            if not na(ret)
                int idx = m * 5 + bucket
                f_update_return_stats(sumR, cntR, winR, idx, ret)
                if doDD
                    float lo_src = f_market_low(m)
                    float entry  = c_L
                    // Lowest low từ t-L đến t (L+1 bars, bao gồm cả bar entry)
                    float lo_L   = ta.lowest(lo_src, L + 1)
                    float dd     = not na(entry) and not na(lo_L) ? lo_L / entry - 1.0 : na
                    if not na(dd)
                        f_update_dd_stats(sumDD, cntDD, idx, dd)

// Helper: update sector RR stats for horizon L
f_update_sector_RR_for_L(int L, float[] sumRR, float[] cntRR, float[] winRR) =>
    float risk_L = risk_pct[L]
    int bucket   = f_bucket_from_risk(risk_L)
    if not na(bucket)
        float cb   = benchmark_close
        float cb_L = cb[L]
        float rb   = not na(cb) and not na(cb_L) ? cb / cb_L - 1.0 : na
        if not na(rb)
            for s = 0 to 10
                float c   = f_sector_close(s)
                float c_L = c[L]
                float rs  = f_compute_return(c, c_L)
                float rr  = not na(rs) and not na(rb) ? rs - rb : na
                if not na(rr)
                    int idx = s * 5 + bucket
                    f_update_return_stats(sumRR, cntRR, winRR, idx, rr)

// Helper: update transition matrix for horizon L
f_update_transition(int L) =>
    int b_from = f_bucket_from_risk(risk_pct[L])
    int b_to   = f_bucket_from_risk(risk_pct)

    if not na(b_from) and not na(b_to)
        int idx = b_from * 5 + b_to

        // Count
        array.set(transCnt, idx, array.get(transCnt, idx) + 1.0)

        // Benchmark return from t-L -> t
        float cb   = benchmark_close
        float cb_L = cb[L]
        float rb   = not na(cb) and not na(cb_L) ? cb / cb_L - 1.0 : na

        if not na(rb)
            array.set(transSumRet, idx, array.get(transSumRet, idx) + rb)
            if rb > 0
                array.set(transWin, idx, array.get(transWin, idx) + 1.0)

// Only update once per equity timeframe bar – mỗi quan sát = 1 bar theo tf_equity
bool is_new_equity_bar = ta.change(time(tf_equity)) != 0
// Đếm số bar equity để hỗ trợ non-overlapping sampling
var int eq_bar_count = 0

f_should_update_for_L(int L) =>
    not use_non_overlap ? true : (eq_bar_count % L == 0)

if is_new_equity_bar
    eq_bar_count += 1

    // Kiểm soát sample window (theo năm)
    bool valid_sample_bar = true
    if use_start_year
        valid_sample_bar := year(time(tf_equity)) >= start_year

    if valid_sample_bar
        if calc_R5 and f_should_update_for_L(5)
            f_update_market_for_L(5,  sumR5_market,  cntR5_market,  winR5_market,  false,        sumDD20_market, cntDD20_market)
            f_update_sector_RR_for_L(5, sumRR5_sector, cntRR5_sector, winRR5_sector)
        if calc_R20 and f_should_update_for_L(20)
            f_update_market_for_L(20, sumR20_market, cntR20_market, winR20_market, calc_DD20,   sumDD20_market, cntDD20_market)
            f_update_sector_RR_for_L(20, sumRR20_sector, cntRR20_sector, winRR20_sector)
        if calc_R60 and f_should_update_for_L(60)
            f_update_market_for_L(60, sumR60_market, cntR60_market, winR60_market, calc_DD60,   sumDD60_market, cntDD60_market)
            f_update_sector_RR_for_L(60, sumRR60_sector, cntRR60_sector, winRR60_sector)
        if show_trans_table
            f_update_transition(trans_L)

// =====================
// 6) BUCKET SELECTION FOR VIEW
// =====================

int bucket_auto = f_bucket_from_risk(risk_pct)
int bucket_sel  = na

if bucket_view == "Auto (current)"
    bucket_sel := bucket_auto
else if bucket_view == "B0 (0–20)"
    bucket_sel := 0
else if bucket_view == "B1 (20–40)"
    bucket_sel := 1
else if bucket_view == "B2 (40–60)"
    bucket_sel := 2
else if bucket_view == "B3 (60–80)"
    bucket_sel := 3
else if bucket_view == "B4 (80–100)"
    bucket_sel := 4

if na(bucket_sel)
    bucket_sel := 2 // fallback: trung tính

// =====================
// 6a) PANEL 1 – MACRO WEATHER SUMMARY (BLOOMBERG STYLE)
// =====================

// Xác định bucket hiện tại (dựa trên risk_pct), fallback về 2 nếu NA
int bucket_cur = f_bucket_from_risk(risk_pct)
if na(bucket_cur)
    bucket_cur := 2

// Helper: mô tả ngắn cho 4 trụ
f_pillar_status(bool flag, string okTxt, string badTxt) =>
    flag ? badTxt : okTxt

string stress_txt = f_pillar_status(stress_high,     "BINH THUONG", "CANG THANG")
string curve_txt  = f_pillar_status(curve_inversion, "BINH THUONG", "DAO NGUOC")
string intl_txt   = f_pillar_status(intl_warning,    "ON DINH",     "AP LUC QT")
string spread_txt = f_pillar_status(spread_warning,  "ON DINH",     "HEP / XAU")

// Lấy thống kê cho VNINDEX tại bucket hiện tại (L=20)
int idx20_cur = 0 * 5 + bucket_cur
float s20_cur = array.get(sumR20_market, idx20_cur)
float c20_cur = array.get(cntR20_market, idx20_cur)
float w20_cur = array.get(winR20_market, idx20_cur)
float avgR20_cur = f_avg(s20_cur, c20_cur)
float winR20_cur = f_winrate(w20_cur, c20_cur)

float sd20_cur = array.get(sumDD20_market, idx20_cur)
float cd20_cur = array.get(cntDD20_market, idx20_cur)
float avgDD20_cur = f_avg(sd20_cur, cd20_cur)

string txt_avgR20_cur = c20_cur > 0 ? str.tostring(avgR20_cur * 100.0, "#.##") + "%" : "--"
string txt_winR20_cur = c20_cur > 0 ? str.tostring(winR20_cur, "#.#") + "%"        : "--"
string txt_avgDD20_cur = cd20_cur > 0 ? str.tostring(avgDD20_cur * 100.0, "#.##") + "%" : "--"

// Bảng tóm tắt macro weather
var table summary_table = na
var table bucket_table  = na
if barstate.islast
    if show_panel1
        if na(summary_table)
            // 3 cột: Label | Value | Ghi chú
            // 7 hàng: header + risk + 4 pillars + VNINDEX stats
            summary_table := table.new(position.top_left, 3, 7, bgcolor=color.new(color.black, 20), border_width=2, border_color=color.new(color.white, 20))
            table.merge_cells(summary_table, 0, 0, 2, 0)
    else
        if not na(summary_table)
            table.delete(summary_table)
            summary_table := na

if barstate.islast and show_panel1 and not na(summary_table)
    string head_txt = " MACRO WEATHER – " + f_bucket_label(bucket_cur) + " | Risk " +
         (na(risk_pct) ? "--" : str.tostring(risk_pct, "#.#") + "%")

    color bg_head = color.new(color.red, 0)
    if bucket_cur == 0
        bg_head := color.new(color.lime, 0)
    else if bucket_cur == 1
        bg_head := color.new(color.teal, 0)
    else if bucket_cur == 2
        bg_head := color.new(color.orange, 0)
    else if bucket_cur == 3
        bg_head := color.new(color.red, 10)

    table.cell(summary_table, 0, 0, head_txt, bgcolor=bg_head, text_color=color.white, text_size=size.small)

    // Risk bucket
    table.cell(summary_table, 0, 1, "Bucket hien tai", bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.tiny)
    table.cell(summary_table, 1, 1, f_bucket_label(bucket_cur), bgcolor=color.new(color.black, 20), text_color=color.white, text_size=size.tiny)
    table.cell(summary_table, 2, 1, "", bgcolor=color.new(color.black, 20))

    // 4 trụ macro
    table.cell(summary_table, 0, 2, "Stress", bgcolor=color.new(color.white, 5), text_color=color.black, text_size=size.tiny)
    table.cell(summary_table, 1, 2, stress_txt, bgcolor=color.new(stress_high ? color.red : color.green, 70), text_color=color.white, text_size=size.tiny)
    table.cell(summary_table, 2, 2, "", bgcolor=color.new(color.black, 20))

    table.cell(summary_table, 0, 3, "Yield curve", bgcolor=color.new(color.white, 5), text_color=color.black, text_size=size.tiny)
    table.cell(summary_table, 1, 3, curve_txt, bgcolor=color.new(curve_inversion ? color.red : color.green, 70), text_color=color.white, text_size=size.tiny)
    table.cell(summary_table, 2, 3, "", bgcolor=color.new(color.black, 20))

    table.cell(summary_table, 0, 4, "Intl diff", bgcolor=color.new(color.white, 5), text_color=color.black, text_size=size.tiny)
    table.cell(summary_table, 1, 4, intl_txt, bgcolor=color.new(intl_warning ? color.red : color.green, 70), text_color=color.white, text_size=size.tiny)
    table.cell(summary_table, 2, 4, "", bgcolor=color.new(color.black, 20))

    table.cell(summary_table, 0, 5, "Spread LS", bgcolor=color.new(color.white, 5), text_color=color.black, text_size=size.tiny)
    table.cell(summary_table, 1, 5, spread_txt, bgcolor=color.new(spread_warning ? color.red : color.green, 70), text_color=color.white, text_size=size.tiny)
    table.cell(summary_table, 2, 5, "", bgcolor=color.new(color.black, 20))

    // VNINDEX behavior (L=20) trong regime hiện tại
    table.cell(summary_table, 0, 6, "VNINDEX (20 bars)", bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.tiny)
    table.cell(summary_table, 1, 6, "AvgR20=" + txt_avgR20_cur + " | Win=" + txt_winR20_cur, bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.tiny)
    table.cell(summary_table, 2, 6, "AvgDD20=" + txt_avgDD20_cur, bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.tiny)

// =====================
// Panel 1 – Bucket Guide o goc trai
// =====================
if barstate.islast
    if show_panel1 and show_bucket_guide
        if na(bucket_table)
            bucket_table := table.new(position.bottom_left, 2, 6,
                                      bgcolor=color.new(color.black, 80),
                                      border_width=1,
                                      border_color=color.new(color.white, 30))
            table.merge_cells(bucket_table, 0, 0, 1, 0)
    else
        if not na(bucket_table)
            table.delete(bucket_table)
            bucket_table := na

if barstate.islast and show_panel1 and show_bucket_guide and not na(bucket_table)
    table.cell(bucket_table, 0, 0, "Macro Risk Buckets",
               bgcolor=color.new(color.blue, 40),
               text_color=color.white,
               text_size=size.tiny)

    table.cell(bucket_table, 0, 1, "B0", text_color=color.white, text_size=size.tiny)
    table.cell(bucket_table, 1, 1, "0–20  : rui ro rat thap", text_color=color.white, text_size=size.tiny)

    table.cell(bucket_table, 0, 2, "B1", text_color=color.white, text_size=size.tiny)
    table.cell(bucket_table, 1, 2, "20–40 : rui ro thap / on", text_color=color.white, text_size=size.tiny)

    table.cell(bucket_table, 0, 3, "B2", text_color=color.white, text_size=size.tiny)
    table.cell(bucket_table, 1, 3, "40–60 : trung lap", text_color=color.white, text_size=size.tiny)

    table.cell(bucket_table, 0, 4, "B3", text_color=color.white, text_size=size.tiny)
    table.cell(bucket_table, 1, 4, "60–80 : rui ro cao", text_color=color.white, text_size=size.tiny)

    table.cell(bucket_table, 0, 5, "B4", text_color=color.white, text_size=size.tiny)
    table.cell(bucket_table, 1, 5, "80–100: cang thang / nguy hiem", text_color=color.white, text_size=size.tiny)

// =====================
// 7) TABLE A – MARKET INDICES REGIME MAP
// =====================

var table market_table = na
if barstate.islast
    if show_panel2
        if na(market_table)
            // 6 columns: Symbol | AvgR20 | Win20 | AvgR60 | AvgDD20 | N20
            // 8 rows   : header + col headers + 6 indices
            market_table := table.new(position.top_right, 6, 8, bgcolor=color.new(color.black, 20), border_width=2, border_color=color.new(color.white, 20))
            table.merge_cells(market_table, 0, 0, 5, 0)
    else
        if not na(market_table)
            table.delete(market_table)
            market_table := na

if barstate.islast and show_panel2 and not na(market_table)
    string header_txt = " Market Regime Map  –  " + f_bucket_label(bucket_sel) + "  |  Risk " + (na(risk_pct) ? "--" : str.tostring(risk_pct, "#.#") + "%")
    table.cell(market_table, 0, 0, header_txt, bgcolor=color.new(color.blue, 0), text_color=color.white, text_size=size.small)

    // Header row
    table.cell(market_table, 0, 1, "Symbol",  bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(market_table, 1, 1, "AvgR20",  bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(market_table, 2, 1, "Win20%",  bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(market_table, 3, 1, "AvgR60",  bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(market_table, 4, 1, "AvgDD20", bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(market_table, 5, 1, "N20",     bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)

    // Rows for 6 market indices
    for m = 0 to 5
        int row = m + 2
        string name = array.get(market_name, m)

        int idx20 = m * 5 + bucket_sel
        float s20 = array.get(sumR20_market, idx20)
        float c20 = array.get(cntR20_market, idx20)
        float w20 = array.get(winR20_market, idx20)
        float avgR20 = f_avg(s20, c20)
        float winR20 = f_winrate(w20, c20)

        int idx60 = m * 5 + bucket_sel
        float s60 = array.get(sumR60_market, idx60)
        float c60 = array.get(cntR60_market, idx60)
        float avgR60 = f_avg(s60, c60)

        float sd20 = array.get(sumDD20_market, idx20)
        float cd20 = array.get(cntDD20_market, idx20)
        float avgDD20 = f_avg(sd20, cd20)

        bool enough_market = c20 >= min_N_market

        string txt_avgR20 = enough_market and c20 > 0 ? str.tostring(avgR20 * 100.0, "#.##") + "%" : "--"
        string txt_winR20 = enough_market and c20 > 0 ? str.tostring(winR20, "#.#") + "%"        : "--"

        string txt_avgR60 = ""
        if show_R60_cols
            if calc_R60 and enough_market and c60 > 0
                txt_avgR60 := str.tostring(avgR60 * 100.0, "#.##") + "%"
            else if calc_R60
                txt_avgR60 := "--"
            else
                txt_avgR60 := "OFF"

        string txt_avgDD20 = ""
        if show_DD_cols
            if calc_DD20 and enough_market and cd20 > 0
                txt_avgDD20 := str.tostring(avgDD20 * 100.0, "#.##") + "%"
            else if calc_DD20
                txt_avgDD20 := "--"
            else
                txt_avgDD20 := "OFF"
        string txt_N20     = c20 > 0 ? str.tostring(math.round(c20)) : "0"
        if not enough_market and c20 > 0
            txt_N20 := "N<" + str.tostring(min_N_market)

        table.cell(market_table, 0, row, name,        bgcolor=color.new(color.black, 10), text_color=color.white, text_size=size.small)
        table.cell(market_table, 1, row, txt_avgR20,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
        table.cell(market_table, 2, row, txt_winR20,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
        table.cell(market_table, 3, row, txt_avgR60,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
        table.cell(market_table, 4, row, txt_avgDD20, bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
        table.cell(market_table, 5, row, txt_N20,     bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)

// =====================
// 8) TABLE B – SECTOR ROTATION MAP (RR20)
// =====================

var table sector_table = na
if barstate.islast
    if show_panel3
        if na(sector_table)
            // 4 columns: Rank | Sector | AvgRR20 | N
            // 12 rows  : header + info + top3 + bottom3
            sector_table := table.new(position.bottom_right, 4, 12, bgcolor=color.new(color.black, 15), border_width=2, border_color=color.new(color.white, 20))
            table.merge_cells(sector_table, 0, 0, 3, 0)
    else
        if not na(sector_table)
            table.delete(sector_table)
            sector_table := na

if barstate.islast and show_panel3 and not na(sector_table)
    string headB = " Sector Rotation Map – " + f_bucket_label(bucket_sel) + "  |  RR vs HOSE:VNINDEX"
    table.cell(sector_table, 0, 0, headB, bgcolor=color.new(color.teal, 0), text_color=color.white, text_size=size.small)

    table.cell(sector_table, 0, 1, "Bucket: " + f_bucket_label(bucket_sel), bgcolor=color.new(color.white, 5), text_color=color.black, text_size=size.tiny)

    // Prepare AvgRR20 per sector in current bucket
    float[] avgRR = array.new_float(11, na)
    float[] cntRR = array.new_float(11, na)
    for s = 0 to 10
        int idx = s * 5 + bucket_sel
        float sum_rr = array.get(sumRR20_sector, idx)
        float cnt_rr = array.get(cntRR20_sector, idx)
        float avg    = f_avg(sum_rr, cnt_rr)
        array.set(avgRR, s, avg)
        array.set(cntRR, s, cnt_rr)

    // Helper arrays for ranking
    int[] topIdx = array.new_int(3, -1)
    int[] botIdx = array.new_int(3, -1)
    bool[] usedTop = array.new_bool(11, false)
    bool[] usedBot = array.new_bool(11, false)

    // Top 3 (largest AvgRR)
    for k = 0 to 2
        float bestVal = na
        int   bestIdx = -1
        for s = 0 to 10
            float v   = array.get(avgRR, s)
            float cnt = array.get(cntRR, s)
            bool used = array.get(usedTop, s)
            if not used and not na(v) and cnt >= min_N_sector
                if bestIdx == -1 or v > bestVal
                    bestVal := v
                    bestIdx := s
        array.set(topIdx, k, bestIdx)
        if bestIdx != -1
            array.set(usedTop, bestIdx, true)

    // Bottom 3 (smallest AvgRR)
    for k = 0 to 2
        float worstVal = na
        int   worstIdx = -1
        for s = 0 to 10
            float v   = array.get(avgRR, s)
            float cnt = array.get(cntRR, s)
            bool used = array.get(usedBot, s)
            if not used and not na(v) and cnt >= min_N_sector
                if worstIdx == -1 or v < worstVal
                    worstVal := v
                    worstIdx := s
        array.set(botIdx, k, worstIdx)
        if worstIdx != -1
            array.set(usedBot, worstIdx, true)

    // Top 3 section
    table.cell(sector_table, 0, 2, "Top 3 outperform (AvgRR20)", bgcolor=color.new(color.green, 20), text_color=color.white, text_size=size.small)
    table.cell(sector_table, 0, 3, "Rank",   bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(sector_table, 1, 3, "Sector", bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(sector_table, 2, 3, "AvgRR20",bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(sector_table, 3, 3, "N",      bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)

    for k = 0 to 2
        int row  = 4 + k
        int idxS = array.get(topIdx, k)
        string rankTxt = "T" + str.tostring(k + 1)
        if idxS == -1
            table.cell(sector_table, 0, row, rankTxt, bgcolor=color.new(color.black, 20), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 1, row, "--",    bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 2, row, "--",    bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 3, row, "0",     bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
        else
            string nm  = array.get(sector_name, idxS)
            float avg  = array.get(avgRR, idxS)
            float cnt  = array.get(cntRR, idxS)
            string avgTxt = str.tostring(avg * 100.0, "#.##") + "%"
            string cntTxt = str.tostring(math.round(cnt))

            table.cell(sector_table, 0, row, rankTxt, bgcolor=color.new(color.black, 20), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 1, row, nm,      bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 2, row, avgTxt,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 3, row, cntTxt,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)

    // Bottom 3 section
    table.cell(sector_table, 0, 7, "Bottom 3 underperform (AvgRR20)", bgcolor=color.new(color.red, 20), text_color=color.white, text_size=size.small)
    table.cell(sector_table, 0, 8, "Rank",   bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(sector_table, 1, 8, "Sector", bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(sector_table, 2, 8, "AvgRR20",bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(sector_table, 3, 8, "N",      bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)

    for k = 0 to 2
        int row  = 9 + k
        int idxS = array.get(botIdx, k)
        string rankTxt = "B" + str.tostring(k + 1)
        if idxS == -1
            table.cell(sector_table, 0, row, rankTxt, bgcolor=color.new(color.black, 20), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 1, row, "--",    bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 2, row, "--",    bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 3, row, "0",     bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
        else
            string nm  = array.get(sector_name, idxS)
            float avg  = array.get(avgRR, idxS)
            float cnt  = array.get(cntRR, idxS)
            string avgTxt = str.tostring(avg * 100.0, "#.##") + "%"
            string cntTxt = str.tostring(math.round(cnt))

            table.cell(sector_table, 0, row, rankTxt, bgcolor=color.new(color.black, 20), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 1, row, nm,      bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 2, row, avgTxt,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)
            table.cell(sector_table, 3, row, cntTxt,  bgcolor=color.new(color.black, 30), text_color=color.white, text_size=size.small)

// =====================
// 9) PANEL 3 – TRANSITION PROBABILITY SUMMARY (MACRO BUCKETS)
// =====================

var table trans_table = na

if barstate.islast
    if show_panel4 and show_trans_table
        if na(trans_table)
            // 3 columns: Direction | Prob | N
            // 5 rows   : header + Up + Same + Down
            trans_table := table.new(position.bottom_left, 3, 5, bgcolor=color.new(color.black, 15),
                                     border_width=2, border_color=color.new(color.white, 20))
            table.merge_cells(trans_table, 0, 0, 2, 0)
    else
        if not na(trans_table)
            table.delete(trans_table)
            trans_table := na

if barstate.islast and show_panel4 and show_trans_table and not na(trans_table)
    int b_now = f_bucket_from_risk(risk_pct)
    if na(b_now)
        b_now := 2

    string h = " Transition Summary (L=" + str.tostring(trans_L) + ")  |  From " + "B" + str.tostring(b_now)
    table.cell(trans_table, 0, 0, h, bgcolor=color.new(color.orange, 0), text_color=color.white, text_size=size.small)

    // Tính tổng theo hàng của bucket hiện tại
    float rowTot = 0.0
    for c = 0 to 4
        rowTot += array.get(transCnt, b_now * 5 + c)

    float upCnt   = 0.0
    float sameCnt = 0.0
    float downCnt = 0.0

    for c = 0 to 4
        float cnt = array.get(transCnt, b_now * 5 + c)
        if c > b_now
            upCnt += cnt
        else if c == b_now
            sameCnt += cnt
        else
            downCnt += cnt

    float p_up   = rowTot > 0 ? upCnt   / rowTot * 100.0 : na
    float p_same = rowTot > 0 ? sameCnt / rowTot * 100.0 : na
    float p_down = rowTot > 0 ? downCnt / rowTot * 100.0 : na

    // Header row
    table.cell(trans_table, 0, 1, "Huong chuyen", bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(trans_table, 1, 1, "Xac suat %",  bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)
    table.cell(trans_table, 2, 1, "So mau (N)",  bgcolor=color.new(color.white, 10), text_color=color.black, text_size=size.small)

    // Up
    table.cell(trans_table, 0, 2, "Len bucket cao hon", bgcolor=color.new(color.green, 20), text_color=color.white, text_size=size.small)
    table.cell(trans_table, 1, 2, na(p_up) ? "--" : str.tostring(p_up, "#.#") + "%", bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.small)
    table.cell(trans_table, 2, 2, str.tostring(math.round(upCnt)), bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.small)

    // Same
    table.cell(trans_table, 0, 3, "O lai bucket hien tai", bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(trans_table, 1, 3, na(p_same) ? "--" : str.tostring(p_same, "#.#") + "%", bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.small)
    table.cell(trans_table, 2, 3, str.tostring(math.round(sameCnt)), bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.small)

    // Down
    table.cell(trans_table, 0, 4, "Giam ve bucket thap hon", bgcolor=color.new(color.red, 20), text_color=color.white, text_size=size.small)
    table.cell(trans_table, 1, 4, na(p_down) ? "--" : str.tostring(p_down, "#.#") + "%", bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.small)
    table.cell(trans_table, 2, 4, str.tostring(math.round(downCnt)), bgcolor=color.new(color.black, 25), text_color=color.white, text_size=size.small)
